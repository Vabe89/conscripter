{"version":3,"file":"static/webpack/static/development/pages/index.js.b4d871edbdea4caa502c.hot-update.js","sources":["webpack:///./state/actions.js"],"sourcesContent":["import fetch from 'isomorphic-unfetch'\nimport * as PathParser from './reducers/fonts/parsePath'\nimport * as msgpack from 'msgpack-lite'\n\n\nimport {\n  FETCH_FONTS,\n  ADD_SUBSTITUTION,\n  SELECT_SUBSTITUTION,\n  UPDATE_SUBSTITUTION,\n  CANCEL_SUBSTITUTION,\n  REMOVE_SUBSTITUTION,\n  DOWNLOAD,\n  SET_FONTNAME,\n  SWAP_SUBSTITUTION,\n  SAVE,\n  LOAD,\n  SHARE\n} from './actionTypes'\n\nimport {\n  STATUS_OK,\n  STATUS_ERROR\n} from './status'\nimport slugify from 'slugify';\n\n/**\n * Fetches and parses the base font\n * @returns {*} dispatchable event object\n */\nexport function fetchFonts() {\n  return dispatch => {\n    dispatch({ type: FETCH_FONTS })\n    return fetch(BASE_LINK + '/static/AVHersheySimplexMedium.otf')\n      .then(response => {\n        if (response.status !== 200) {\n          dispatch(fetchFontError())\n          throw new Error('Non 200 response')\n        } else {\n          return response.arrayBuffer()\n        }\n      })\n      .then(buffer => {\n        dispatch(fetchFontResult(buffer))\n      })\n  }\n}\n\n/**\n * Result of fetching the font\n * @returns {*} dispatchable event object\n */\nexport function fetchFontResult(buffer) {\n  return {\n    type: FETCH_FONTS,\n    status: STATUS_OK,\n    buffer\n  }\n}\n\n/**\n * Result of fetching the font when an error occurs\n * @returns {*} dispatchable event object\n */\nexport function fetchFontError() {\n  return {\n    type: FETCH_FONTS,\n    status: STATUS_ERROR\n  }\n}\n\nexport function updateSubstitutionGlyph(meta,svg) {\n  const parser = new PathParser(meta)\n  const { commands, warnings } = parser.parse(svg)\n  return {\n    type: UPDATE_SUBSTITUTION,\n    field: 'glyph/commands',\n    warnings,\n    value: commands\n  }\n}\n\nexport function updateSubstitutionReplace(value) {\n  return {\n    type: UPDATE_SUBSTITUTION,\n    field: 'replace',\n    value\n  }\n}\n\nexport function updateSubstitutionAdvanceWidth(value) {\n  return {\n    type: UPDATE_SUBSTITUTION,\n    field: 'glyph/advanceWidth',\n    value\n  }\n}\n\nexport function removeSubstitution({ active }) {\n  return dispatch => {\n    dispatch({\n      type: REMOVE_SUBSTITUTION,\n      substitution: active\n    })\n    dispatch(cancelSubstitution())\n  }\n}\n\nexport function cancelSubstitution() {\n  return { type: CANCEL_SUBSTITUTION }\n}\n\nexport function submitSubstitution({ active, currentGlyph, currentReplace }) {\n  return dispatch => {\n    dispatch({\n      type: ADD_SUBSTITUTION,\n      substitution: {\n        replace: [currentReplace],\n        glyph: currentGlyph\n      },\n      replace: active\n    })\n    dispatch(cancelSubstitution())\n  }\n}\n\nexport function selectSubstitution(substitution) {\n  return {\n    type: SELECT_SUBSTITUTION,\n    substitution: substitution || {\n      replace: [''],\n      glyph: {\n        advanceWidth: 1000,\n        commands: []\n      }\n    }\n  }\n}\n\nexport function download() {\n  return { type: DOWNLOAD }\n}\n\nexport function setFontName(value) {\n  return {\n    type: SET_FONTNAME,\n    value\n  }\n}\n\nexport function swapSubstitution(a, b) {\n  return {\n    type: SWAP_SUBSTITUTION,\n    a,\n    b\n  }\n}\n\nexport function save({ fonts: { substitutions, fontname }}) {\n  const data = 'data:text/json;charset=utf-8,' + encodeURIComponent(JSON.stringify({ version: '0.1.0', substitutions, fontname }))\n  const container = document.createElement('a')\n  container.setAttribute('href', data)\n  container.setAttribute('download', slugify(fontname || 'conscripter-custom-font') + '.json')\n  container.click()\n  return {\n    type: SAVE\n  }\n}\n\nexport function share({ fonts: { substitutions, fontname }}) {\n  const data = { substitutions, fontname }\n  const buf = msgpack.encode(data)\n  return {\n    type: SHARE,\n    encoded: buf.toString(16)\n  }\n}\n\nexport function load() {\n  return dispatch => {\n    const loader = document.createElement('input')\n    loader.setAttribute('type', 'file')\n    loader.setAttribute('accept', 'text/json')\n    loader.onchange = e => {\n      const file = e.target.files[0]\n      const reader = new FileReader()\n      reader.onload = () => {\n        try {\n          const { substitutions = [], fontname = 'My Custom Font' } = JSON.parse(reader.result)\n          dispatch({\n            type: LOAD,\n            error: null,\n            substitutions,\n            fontname\n          })\n        } catch (e) {\n          dispatch({\n            type: LOAD,\n            error: new Error('Unable to parse selected JSON: did it come from Conscripter?'),\n            substitutions: [],\n            fontname: 'My Custom Font'\n          })\n        }\n      }\n      reader.readAsText(file)\n    }\n    loader.click()\n  }\n}"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AAGA;AAeA;AAIA;AAEA;;;;;AAIA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;AAIA;AACA;AACA;AACA;AACA;AAHA;AAKA;AAEA;;;;;AAIA;AACA;AACA;AACA;AAFA;AAIA;AAEA;AACA;AACA;AAFA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AACA;AACA;AACA;AACA;AAHA;AAKA;AAEA;AACA;AACA;AACA;AACA;AAHA;AAKA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AANA;AAQA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAFA;AAFA;AAUA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAFA;AAIA;AAEA;AACA;AACA;AACA;AACA;AAHA;AAKA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAFA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;;;;A","sourceRoot":""}